---
interface Props {
  heading?: string;
  description?: string;
  stats: Array<{
    value: string;
    label: string;
    description?: string;
    icon?: string;
  }>;
  backgroundType?: 'light' | 'dark' | 'gradient';
  theme?: 'default' | 'gold' | 'emerald';
}

const {
  heading,
  description,
  stats,
  backgroundType = 'gradient',
  theme = 'default'
} = Astro.props;

const themeConfig = {
  default: {
    gradient: 'bg-gradient-to-r from-blue-900 via-indigo-900 to-purple-900',
    decorative: ['bg-blue-400/10', 'bg-purple-400/10'],
    accent: 'text-blue-100',
    statValue: 'text-white',
    statLabel: 'text-blue-200',
    statDesc: 'text-blue-300'
  },
  gold: {
    gradient: 'bg-gradient-to-r from-slate-900 via-amber-900 to-yellow-900',
    decorative: ['bg-amber-400/10', 'bg-yellow-400/10'],
    accent: 'text-amber-100',
    statValue: 'text-white',
    statLabel: 'text-amber-200',
    statDesc: 'text-amber-300'
  },
  emerald: {
    gradient: 'bg-gradient-to-r from-slate-900 via-emerald-900 to-teal-900',
    decorative: ['bg-emerald-400/10', 'bg-teal-400/10'],
    accent: 'text-emerald-100',
    statValue: 'text-white',
    statLabel: 'text-emerald-200',
    statDesc: 'text-emerald-300'
  }
};

const currentTheme = themeConfig[theme as keyof typeof themeConfig];

const bgClasses: Record<string, string> = {
  light: 'bg-white',
  dark: 'bg-gray-900',
  gradient: currentTheme.gradient
};

const textClasses: Record<string, string> = {
  light: 'text-gray-900',
  dark: 'text-white',
  gradient: 'text-white'
};
---

<section class={`py-20 ${bgClasses[backgroundType]} relative overflow-hidden`}>
  <!-- Background Elements -->
  {backgroundType === 'gradient' && (
    <div class="absolute inset-0">
      <div class={`absolute top-0 left-1/4 w-96 h-96 ${currentTheme.decorative[0]} rounded-full blur-3xl`}></div>
      <div class={`absolute bottom-0 right-1/4 w-96 h-96 ${currentTheme.decorative[1]} rounded-full blur-3xl`}></div>
    </div>
  )}

  <div class="container px-6 relative z-10">
    {(heading || description) && (
      <div class="text-center mb-16">
        {heading && (
          <h2 class={`text-4xl md:text-5xl font-bold mb-6 ${textClasses[backgroundType]}`}>
            {heading}
          </h2>
        )}
        {description && (
          <p class={`text-xl max-w-3xl mx-auto ${backgroundType === 'gradient' ? currentTheme.accent : backgroundType === 'dark' ? 'text-gray-300' : 'text-gray-600'}`}>
            {description}
          </p>
        )}
      </div>
    )}

    <div class="flex flex-wrap justify-center items-start gap-4 lg:gap-8">
      {stats.map((stat: Props['stats'][0], index: number) => (
        <div class="text-center group max-w-[200px] flex-shrink-0">
          {stat.icon && (
            <div class="text-3xl mb-4 group-hover:scale-110 transition-transform duration-300">
              {stat.icon}
            </div>
          )}
          <div class={`text-3xl md:text-4xl font-bold mb-3 ${backgroundType === 'gradient' ? currentTheme.statValue : backgroundType === 'dark' ? 'text-white' : 'text-blue-600'}`}>
            <span class="counter" data-value={stat.value}>
              {stat.value}
            </span>
          </div>
          <div class={`text-base font-semibold mb-2 ${backgroundType === 'gradient' ? currentTheme.statLabel : backgroundType === 'dark' ? 'text-gray-300' : 'text-gray-900'}`}>
            {stat.label}
          </div>
          {stat.description && (
            <div class={`text-xs leading-relaxed ${backgroundType === 'gradient' ? currentTheme.statDesc : backgroundType === 'dark' ? 'text-gray-400' : 'text-gray-600'}`}>
              {stat.description}
            </div>
          )}
        </div>
      ))}
    </div>
  </div>
</section>

<script>
  // Improved counter animation
  function animateCounter(element: HTMLElement, finalValue: string) {
    const numericValue = parseInt(finalValue.replace(/[^\d]/g, '')) || 0;
    const suffix = finalValue.replace(/[\d]/g, '');
    
    if (numericValue === 0) {
      element.textContent = finalValue;
      return;
    }
    
    let current = 0;
    const increment = numericValue / 60; // 60 frames for 1.5 seconds at 40ms intervals
    const timer = setInterval(() => {
      current += increment;
      if (current >= numericValue) {
        current = numericValue;
        clearInterval(timer);
      }
      element.textContent = Math.floor(current).toString() + suffix;
    }, 25); // Slightly faster animation
  }

  // Intersection Observer for counter animation
  const observerOptions: IntersectionObserverInit = {
    threshold: 0.3,
    rootMargin: '0px 0px -10px 0px'
  };

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const counters = entry.target.querySelectorAll('.counter');
        counters.forEach(counter => {
          const finalValue = (counter as HTMLElement).getAttribute('data-value') || '0';
          animateCounter(counter as HTMLElement, finalValue);
        });
        observer.unobserve(entry.target);
      }
    });
  }, observerOptions);

  // Observe stats sections when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const statsGrids = document.querySelectorAll('[class*="grid-cols-1"]');
    statsGrids.forEach(grid => {
      if (grid.querySelector('.counter')) {
        observer.observe(grid);
      }
    });
  });
</script>
